# 1,java中的内存模型是如何设计的
### Java中的内存模型主要包括堆、栈、方法区、本地方法栈
堆：Java内存管理中最大的一块，被所有线程共享，存放对象实例和数组

栈：每个线程运行时都会创建一个栈，用于存放局部变量、操作数、动态链接、方法出口等，其生命周期和线程同步

方法区：被所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量等数据

本地方法栈：处理本地方法的调用

Java内存模型还包括程序计数器等组件，构成了Java运行时数据区。

# 2，Java多线程中，synchronized和ReentrantLock的区别是什么？
### synchronized和ReentrantLock都是用于控制多线程访问同步资源的机制，解决线程安全的工具，区别：
锁的实现方式：synchronized，Java内置的关键字，依赖于JVM实现，属于悲观锁机制，ReentrantLock是Java提供的API，J.U.C.包下的接口，有很多实现类，属于乐观锁机制

锁的公平性：ReentrantLock可以指定为公平锁或非公平锁，synchronized只能是非公平锁（公平和非公平指的是线程竞争资源时是否可以插队）

锁的灵活性：ReentrantLock提供了更多功能，可以中断等待锁的线程，获取等待锁的线程列表，还可以尝试获取锁

性能：JDK1.6之后，两者性能相近

锁的细粒度控制：ReentrantLock可以精确的控制锁，更加丰富的锁操作

```
//第一种：控制方法
publich synchronized void sync(){
}
//第二种：控制代码块
Object lock = new Object();
public void sync(){
  synchronized(lock){}
}
//reentrantLock控制方法
Lock lock = ReentrantLock();
public void sync(){
lock.lock(); //添加锁
//线程代码
lock.unlock();//释放锁}

```

